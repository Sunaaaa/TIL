# Computational Thinking

## 0. 프로그래밍과 논리 / 수학

### 프로그래밍이 어려운 점!

1. 프로그래밍 언어 문법과 라이브러리 사용

   - 언어를 배우지 않으면 알 수 없고, 스펠링 하나만 틀려도 실행되지 않음 

2. 논리 (Hard Logic)

   - Hard Logic VS Soft Logic

     맥주집 문제 VS 카드 문제

     - Hard Logic
     - Soft Logic

   - **직관**은 논리적인 느낌을 부여

     - 익숙한 상황에서 빠르지만, 정확하지 않고 가끔은 익숙한 상황에서도 틀린다. 또 강한 착각/선입견을 일으킨다. 
     - 같은 표현을 사용하지만 의미가 다르다는 것을 알고 있음 
       - "버스 타려는데 천원 있니?"에는 천원 이상이 있는지 물어보는 것 
         - 천원이 있든 만원이 있든 천원이 있다고 얘기할 수 있음
       - "과자 몇개 먹었니?" 에는 정확한 개수를 요구
         - 3개 먹었지만 1개를 먹은 것도 사실이긴함
       - "합격하려면 A 500점 이상 혹은 B 600점 이상이 필요"에는 **A와 B Inclusive**
         - A와 B 둘다 가능!
       - "복권 당첨 시 A 혹은 B"에는 **A와 B Exclusive**
         - A 또는 B 하나만 가능!



## 1. 논리와 증명

> 일상 생활에서는 Soft Logic이 빠르기 때문에 유용
>
> - 논리적으로 부정확한 표현 사용, 그러나 어떤 의미인지 모든 사람이 이미 알고 있다.
>
> 
>
> 프로그래밍에서는 Hard Logic
>
> - 프로그래밍 언어의 표현들이 모두 논리학에서 나옴
> - 사용되는 수많은 알고리즘을 이해하기 위해서 필수!



**직관으로 알고리즘을 이해하는 것은 부적절!**

**증명을 해야한다!**



### 1.1 논리

#### 1.1.1 문제1

> **"p이면 q이다"**
>
> - 만약 p가 거짓인 경우, 전체는 참
>
>   - 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다. 
>     - p : 거짓
>     - q : 알 수 없음
>
>   - 100점을 맞으면 치킨을 사준다. 
>     - 100점을 맞았는데 치킨을 안 사주면 약속을 어긴 것
>     - 만약 100점을 못맞았을 때 치킨을 사줘도 약속을 어긴 것은 아님
>
> 
>
> - p의 사실 여부와 무관하게, q가 참이면, 전체는 항상 참
>   - 만약 19893827938274839이 Prime Number라면, 2는 짝수이다. 
>     - p : 알 수 없음
>     - q : 참



#### 1.1.2 문제2

> p와 q가 명제이고, p->q가 거짓이라고 하자. 다음 명제식의 참/거짓을 판별하라
>
> - p가 참, q가 거짓인 경우만 성립
>
> ```
> ~p -> q
> "참"
> ```
>
> ```
> p v q
> "참"
> ```
>
> ```
> q->p
> "참"
> ```
>
> 



#### 1.1.3 문제3

> 다음 명제들의 역,이,대우를 작성하라
>
> 1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다. 
>    - 역 : 미국에서 2080년 월드컵이 열리면, 0이 홀수이다. 
>    - 이 : 0이 홀수가 아니면, 미국에서 2080년 월드컵이 열리지 않는다. 
>    - 대우 : 미국에서 2080년 월드컵이 열리지 않으면, 0이 홀수가 아니다. 
> 2. 만약 19893827938274839이 Prime Number라면, 2는 짝수이다. 
>    - 역 : 2가 짝수이면, 19893827938274839이 Prime Number이다.
>    - 이 : 19893827938274839이 Prime Number가 아니면, 2는 홀수이다. 
>    - 대우 : 2가 홀수이면, 19893827938274839이 Prime Number가 아니다.



#### 1.1.4 문제4

> 다음 명제식의 진리표를 만드시오
>
> ```
> p ∧ (q -> ~p)
> ```
>
> ```
> (p ∧ ~q) -> r
> ```
>
> 



### 1.2 증명

> **정확하게 확인하는 과정을 수많은 세우러동안 정리해 둔 것이 증명 기법**
>
> - 딱딱한 것이 아닌 기발한 아이디어들의 집합이고 "이해하면 재미있는 그림"들과 같다.



- 정확한 명제식으로 표현할 수 있는 것, 명제식으로 바꿀 수 있음

  

#### 1.2.1 당구공 Paradox

> 수학적 귀납법
>
> - P(1)이 참이고, P(n) -> P(n+1)이 참이면, P(n)은 모든 자연수 n에 대해 참이다. 

- 모든 자연수 n에 대해 당구공 n개가 들어있는 집합에서, 그 집합에 포함된 당구공은 모두 색이 같다는 것을 증명함
  - n개의 당구공 중 임의의 1개를 빼도, 뺐던 당구공을 다시 넣어도 모든 당구공의 색은 같다. 



#### 1.2.2 당구공 틀린 부분 찾기

> P(n) 이 참이라고 가정할 수 없다는 반롭
>
> - P(n) -> P(n+1)이 참임을 보이기만 하는 것이 수학적 귀납법!
>
> 그래서 P(n)이 참일 필요는 없다. P(n)이 거짓이어도 참일 수 있기 때문에 의미 없다. 



**실제 틀린 부분 **

- n=1인 경우, 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알 수 없음
  - n=2인 경우, 하나를 뻇기 때문에 색이 같은 것
  - 제대로된 증명을 하기 어렵다.



#### 1.2.3 Infinity Many Prime Number

> Prime Number가 무한히 많다는 것을 증명



> Prime Number의 개수가 유한한 k개
>
> - 모든 Prime Number를 P1, P2,...
>
> 모든 Prime Number를 다 곱하고 1을 더한 수를 n
>
> - n은 모든 Prime Number보다 큰 수 
> - Prime Number이 아니기 떄문에, 소인수분해가 되어야 한다. 
>   - 어떤 Prime Number으로 나눠도 나누어 떨어져야 한다.





**실제 틀린 부분 **

n은 어떤 Prime으로 나누어도 나머지가 1이다. 

n은 어떤 Prime보다도 크므로 합성수이다.

합성수이지만, 어떤 Prime으로도 나누어지지 않기 때문에 모순



**몇 개의 Prime이 더 존재하면 되는 것이 아니냐는 주장 존재**

- "Prime Number가 k개 이면 모순 발생"

  "Prime Number"가 k개 -> "항상 거짓"

  **참.사실**

  - q가 거짓이기 때문에 전체가 참이 되기 위해선 p가 거짓이어야 한다. 
    - "Prime Number"가 k개 가 거짓이어야함



### 1.3 수학적 귀납법

#### 1.3.1 수학적 귀납법의 기본형

- P(1)이 참이고, P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다. 



#### 1.3.2 수학적 귀납법의 강한 형태

- P(1)이 참이고, P(1) P(2) ... P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다. 
  - P(1)부터 P(n)까지가 모두 참이면 P(n+1)이 참이다. 



#### 1.3.3 수학적 귀납법의 예제

- 다음 함수가 1부터 x까지의 합을 계산함을 증명해보라.

  ```c
  int sum(int x){
  	if (x <= 0) return 0;
  	return x + sum(x-1);
  }
  ```

- **증명이 가능한 명제를 만들자**

  - 명제 : sum(x)가 리턴하는 값은 1+2+...+x의 값과 항상 같다.

- **수학적 귀납법 적용**

  - a

- sum(x-1)를 블랙박스로 보자

  - sum(x-1)이 실제로 제대로된 값을 리턴한다고 가정한다. 



#### 1.3.4 버블 소트의 증명



### 1.4 문제

#### 문제1



#### 문제2



#### 문제3



#### 문제4



#### 문제5



#### 문제6



#### 문제7



#### 문제8



#### 문제9



#### 문제10



#### 문제11



#### 문제12



#### 문제13



#### 문제14



#### 문제15



#### 문제16



#### 문제17



#### 문제18



#### 문제19



#### 문제20



#### 문제21



#### 문제22



#### 문제23



## 2. 수와 표현

> 컴퓨터는 0 또는 1을 표현할 수 있는 비트들을 모아 수를 표현한다. 
>
> k개의 비트를 사용하면 0부터 2 <sup>k</sup> -1 까지 표현 가능
>
> - 어떤 경우든 최대 2 <sup>k</sup> 가지의 값을 표현하는 것이 가능
> - 10진수로 k자리를 쓰면 0부터 10<sup>k</sup>-1 까지 표현이 가능한 것과 동일
>   - 10진수로 1자리 -> 0~9 까지 표현가능
>   - 10진수로 2자리 -> 0~99 까지 표현가능
>   - 10진수로 100자리 -> 읽을 수도 없을 정도로 큰 값..



**어떤 값 n을 표현하기 위해선 몇 개의 비트가 필요할까?**

2<sup>k</sup>-1 >= n이 성립해야함! 	=> 	2<sup>k</sup> >= n+1 	=> 	k >= log(n+1) 	=> 	약 log n 비트가 필요

- x = log n 과 2<sup>x</sup> = n 는 동일!

  > log n
  >
  > - 2의 몇 승이 n이 되느냐
  > - n을 표현하는데 몇 비트가 필요하느냐
  > - 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐
  > - n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐

- x = log n 일 때, x 가 n 보다 더 작고, n이 커질수록 매우 달라진다.

- 컴퓨터 분야에서 로그의 밑은 항상 2이다. 

  > 32비트 컴퓨터의 주소 공간은 2<sup>32</sup> = 약 40억개 주소
  >
  > 



### 2.1 문제

#### 2.1.1 문제1

#### 2.1.2 문제2

#### 2.1.3 문제3

#### 2.1.4 문제4

#### 2.1.5 문제5





## 3. 집합과 조합론





## 4. 기초 수식





## 5. 재귀





## 6. 동적 프로그래밍





## 7. 조합론 프로그램 과제





## 8. 기초 알고리즘 프로그램 과제 